 Подсистема внедрения DLL.
  Вариант с использованием отладочного режима
 может давать нееоднократные ошибки, особенно
 если процесс не любит когда его кто-то отлаживает.
  Вариант с использованием ловушек (способ MS)
 потребует двух DLL, одна из которых будет
 существовать только во время внедрения и
 будет способствовать загрузки рабочей DLL.
 В этом случае отпадает использование таких
 функций как OutputDebugString и соответсвующие
 им обработчики в программе.
  В реализации этого способа есть следующее
 полезное отличие - можно производить отладку
 внедренной dll с помощью любого доступного
 отладчика.



  Сложности:
   1 - установка ловушки на однин поток = решенное
   2 - передача сообщения след. ловушке по описателю
       текущей ловушки.
     либо использовать тот-же FileMapping, либо
    ShareMem от Borland?

    Метод ловушек показал себя довольно глючным с
  большими процессами игр, иногда заваливая всю
  систему. Его надо переделать на опциональный
  вариант.

    Нужно реализовать поиск чисел в формате вещественного
 числа, а так-же различных инвариантов строк. Алгоритм
 поиска разбить по подпрограммам.

  23.02.2004 - ликвидирован баг:
  читер не заканчивал цикл при достижении граничного региона,
  а продолжал искать значения в ядре, теперь механизм контроля
  границы находиться в начале цикла. 

  Задействовать колесо мыша. - Complete

  8.04.2004
   Много, очень много багов...
   Добавил вызов пустышки после инициализации динамического кода -
   это должно сбрасывать кэш уровня L1 и загружать его новым кодом.
   Основные варианты диквидации засилья багов - переписывания кода упаковки.

      Надо ориентироваться на высокооптимизорованные алгоритмы поиска
   связываные с побитовой упаковкой смещений. EXAMPLE:
   ------------------------------------------------- +
      mov    ecx, dword ptr [eax][esi]               |
   @MaskIng:                                         |
      and    ecx, 12345678h                          |
   @DCmp1:                                           |   
      cmp    ecx, 12345678h                          |
      inc    eax                                     |
   @DSet0:                                           } Один из 16 блоков
      sete   dl          // Установить в 1           | последовательной
      or     bl, dl                                  | битовой установки
      shl    bx, 1      // Сдвинуть влево            |
   --------------------------------------------------+
   Алгоритм этот предполагает ограничить сброс кэша L1 в 16 раз.
   Скорость по отношению к обычному поиску с упаковкой внутри
   алгоритма возрастет в несколько раз.

 
 31.05.2004

   Новый менеджер памяти. 

 
    Массивы с описателями блоков памяти бутуд разделены по размерам этих блоков,
   например блоки размерами до 32 байт будут хранится в одном, до 256 в другом и
   т. д. Вместо хранения структур применить парралельные массивы, приемлемые для
   кеша L1 (в одном массиве указатель, в втором размер блока, в третьем размер
   блока если он освобожден). Слияние (дефрагментация) освобожденных блоков
   будет производится отдельной подпрограммой вызываемой в удобное время, в
   альтернативе можно будет использовать счетчик (вектор индексов - стек)
   освобожденных блоков. Механизмы предупреждения сбоев должны не только
   формировать код ошибки, но и вызывать исключительные ситуации.
  
 Приоритет: скоростное распределение блоков виртуальной (динамической) памяти.
 Возможности: 
   - один менеждер на несколько процессов
   - резевирование разделяемой памяти с поддержкой имен блоков (FileMapping - single use);
   - возможность задания фоновых, управляемых режимов отгрузки блоков на диски подкачки 
     (интелектуальный сброс при дефиците физической памяти).
   - 
 Наметить переход к overkernel (управляемое ядро надсистемы).
 Менеджер отложен надолго.

 31.07.2004

 Добавление возможности сохранять результаты поиска/отсева для возможности отката
 поиска или отсева.

 Запись в файл производится поблочно. Каждый блок имеет заголовок с индексом,
 размером, и описанием блока. По обыкновению блок представляет собой массив
 смещений внутри региона сканирования.
 ----------------------------------------------------------------
 12.08.2004 - четверг. День. 
 ----------------------------------------------------------------
 До выхода релиза версии 2.29 надо реализовать следующую фичу:

 Быстрый ввод (где возможно) и отображение чит кодов к тем играм которые это позволяют.
 Резон: лень вводить, и запоминать чит коды к играм.
  Быстрый ввод чит-кода активируется зарезервированной горячей клавишей, после чего можно набрать
  номер кода, и wgc сам его "вставит". В большинстве игр перед этим надо вызвать коммандную строку.
 Реализация: механизм сообщений Windows. Программе попросту посылаются сообщения о нажатии тех или
  иных клавиш.
 Вывод чит-кодов (подсказка, и вообще будущий хелп-инсайд) отображние псевдоокна с описанием чит-кодов
  прямо поверх всех окон. Реализуется легко при помощи AddMsg и установки соотв. флажка на 5-ой вкладке.
 Все это дело подразумевает использование некоторой базы чит-кодов (создавать будут все), и автоматического
  связывания этой базы с игрой (в последующих версиях). Пока до этого не дошло, все чит-коды будут покоится в
  соответсвующем Memo

 ----------------------------------------------------------------
 21.08.2004. Версия 2.31

               Реализация подсистемы плагинов
 ----------------------------------------------------------------
   Для поддержки дополнительных типов данных и алгоритмов поиска, в WGC должна быть встроена подсистема
 плагинов. В пользовательском отношении плагин должен отобразить окно для выставления параметров поиска/
 отсева. В этом окне помимо выбора типа данных/поиска должны быть три кнопки: "Поиск", "Отсев" и
 "Отмена". После их нажатия функция отображения должна вернуть ID кнопки, что-бы WGC знал что ему делать.

 Итак что-бы зарегистрироваться плагин обязан поддерживать следующие функции
  RegisterWgcPlugin (var names : PPCharArray) : dword;
  names - указатель на массив строк в которых содержится описание каждой реализованной плагином системе поиска/отсева
  возвращает количество строк в массиве. Этот массив должен быть реализован статически или освобождаться
  программой

 DisplayPlugin (num : dword) : dword;
  При вызове этой функции плагин отображает окно соответсвующее подсистеме поиска/отсева с номером num.
  Пользователь в этом окне должен выбрать тип поиска/отсева, тип данных и ввести образец если требуется.
  При возврате  функция должна вернуть условный ID кнопки нажатой пользователем.

 SearchFirst (buff : Pointer; size : dword;  offests : PWordArray) : dword;
  Эту функцию вызывает wgc для обработки буффера в который скопирован регион памяти программы в которой ведется поиск.
  buff - указатель на буффер с размером size. (Size всегда < 64K);
  offsets - указатель на массив слов (двухбайтных) в котором функция должна сохранять смещения найденых
   значений.
  Функция возвращает количество найденых смещений.

 SearchNext (buff : pointer; offsets : PWordArray; count : dword) :  dword;
  Эту функцию вызывает wgc для отсева смещений.
  
  buff - указатель на буффер
  offsets - указатель на массив смещений найденых в предыдущем поиске/отсеве
  count - количество смещений
  Функция возвращает количество смещений оставшихся после отсева.

 FreePlugin ();
  Эту функцию wgc вызывает при выгрузке плагина. Может использоваться для
  освобождения динамической памяти.

  3.08.2004
  --------------------------------------------------------------------------
  Поиск значений разных типов.
  Реализован элементарно через генератор запросов. Работает пока от коммандной строки.

  31.10.2004  версия 2.32
  --------------------------------------------------------------------------

  Сохранение настроек, дефолтные настройки - максимальная производительность (приоритет).
  Низкоуровневая оптимизация алгоритма поиска и отсева, с вытекающей из этого
  большей скорости поиска.

  Не тут то было... Предстоит очень серьезная декомпозиция, в том числе разбивка
  общей структуры памяти. Идеальное решение - отказ от системы сообщений, особенно
  в связанных условиях (обычный режим, не Spy-mode). Фактическим препятствием здесь
  является нахождение всего ввода в потоке wgc.exe, а поисковых функций в chdip.dll.
  Было бы не плохо разместить класс в общей памяти.

  13.11.2004
  --------------------------------------------------------------------------
   нет ассемблера, потеряно два дня. А до выхода версии 2.4 осталось так мало.

  15ч11м :  маниакальное изменение готово - в окне About, автоматом теперь выставляется версия
  файла wgc.exe.

  15ч54м : добавлена панель для кнопок разного значения. Пока две кнопки для навигации между вкладками.

  18h42m : начаты разборки с завершением потока chdip.dll. Основная проблема - некуда возвращать
  управление и не откуда выгружать библиотеку.

  14.11.2004
  --------------------------------------------------------------------------
   пока выгрузка производится принудительно со стороны wgc.exe. Но пока не возможно завершение
   в Spy-Mode.

   Ничего не понимаю: до этой версии все программы успешно работали с разделяемой структорой,
  сделал эксперимента ради разделяемый класс. Теперь все работает с ним, и назад дороги нет,
  потому что программа перестает функционировать. Тем не менее это создает проблему для
  функционирования Spy-Mode, так как открываемый на стороне зараженного потока объект не имеет
  ничего общего с объектами потоков wgc. Пришлось таки вернуться к структурной системе, проблему
  кстати вызывали две версии ChTypes.

   Короче пью пиво, и переделываю хранилище. Посколько предельно ясно, что доступ к
  хранилищу в любом случае будет последовательный, надо его организовать в виде потока.


  15.11.2004

  1ч20м - МАЗАФАКА!!! Я опять таки вернулся к разделяемому объекту. И ведь дошел до конца.
  Получается до сегодняшней ночи я вообще не представлял как устроен обьект изнутри. Буду
  знать. Весь фокус решения задачи состоит в следующем: В общей памяти хранить надо Instance
  обьекта, а не указатель (оказывается тип TObject сам по себе указатель). Мало того в
  полученной ситуации, перед тем как обьект себя проинициализирует, надо сохранять содержимое
  переменных класса в буффере, а потом воостанавливать их. При этом надо еще не задеть указать
  на VMT, иначе гарантированы глюки и прочее счастье. В общем ночь не зря потрачена, теперь я
  имею обьект доступный из любого процесса!!!
     Кроме того была проделана огромная работа по декомпозиции библиотеки chdip. Большинство
  функций модуля chsrch.pas было распихано по специально созданным для этого классам.
  Было завершено и новое хранилище указателей. Были устранены побочные ссылки на модули Forms,
  ChForm которые раздували размер chdip.dll до 240 кб (упакованная). Сейчас эта либа весит 150 кб, и
  упаковывается в 67 кб, что весьма радует поскольку размер проги в архиве теперь
  упадет до 400 Кб.


  16.11.2004

  21h50m - принес ассемблер, буду отлаживать алгоритмы однако. Сделал ускорение запуска wgc,
  вернее появление главной формы. Добавил код засылки сообщений в Hook инициализатор SpyMode.
  Решил домутить проблему завершения потока chdip.dll. ЙЙЙОООХХУУУУ - получилось. Теперь
  выход их режима Spy в Windows XP, самая простая задача. Очень хочется сделать режим Spy
  безопасным для использования.

  9.12.2004
    Появились сомнения в нормализованности процесса выгрузки chdip.dll. Кое-что сегодня удалось
  поправить, но время от времени возникают странные ошибки.
    Задача осталась следующая: Надо сделать каждую копию chdip.dll полностью независимой, для
  чего некороторые общие переменные должны распределятся по массиву экземпляров.
    Требуется домутить поиск Mixed значений, ведь отстает все только по части решений.

  12.12.2004
     Проделана большая работа. Теперь медленно, но верно можно искать значения типа ALL.
  Кроме это доработана подсистема локализации, и переведены базовые сообщения. Исправлены
  некоторые ошибки.

  Идеи:
  ++ Механизм распределения банков надо реализовать через менеджер банков, дабы исключить
  их регулярное выделение/удаление.
  ++ Так же надо сделать отдельным хранение старой памяти процесса, что позволит использовать
  несколько запросов для поиска неизвестных значений.
  ++ Требуется оптимизировать алгоритмы поиска диапазонов и прочие, поскольку тормоза с поисклм
  значений неизвестного типа в основном связаны с ними.
  --  Печально, но пока невозможно сохранение/загрузка результатов отсеиваний.

  1.01.2005
   = Начата работа над консольной системой. =
     Консольная система может использоваться как однозапросное средство, для управление
   поиском/отсевом изнутри игры. Принцип работы: при нажатии комбинации клавиш, игра
   замораживается и выводится консоль. Обработчик клавиатуры переходит в режим консоли.
   Надо осуществить:
    - отображение символов нажимаемых клавиш в нижней части консоли.
    - отображение информации предоставляемой консолью (чит-коды и т.д).
    - разработать командный интерфейс (привлекательный:) для поиска/отсева значений и
      их прямого изменения (листинг и управление таблицей значений). 

  2.01.2005
  Основные задачи:

   1.  Реализация простого механизма "заморозки" процесса в отношении к пользователю:
  Инварианты: Использовать (WINAPI32::) SuspendThread/ResumeThread, при этом дескрипторы
  потоков могут браться с помощью механизма отладки для Win9x или OpenThread для WinNT5 +.

  Механизмы консоли распологаются на стороне WGC.EXE.

  7.01.2005

   Доработка консоли до уровня "взлом изнутри". Использовать поддержку типов и правил
  при командном задании запроса из консоли.
   Техническая доработка консоли: расширить экранный буффер на всю консоль. Добавить
  "кнопку" закрытия консоли.
    Надо создавать поле EDIT для поглощения ввода после разморозки игры.


  21.01.2005
        Поиск и отсев неизвестного значения. Отладка и ремастеринг.
  Выявлен баг приводящий вылету потока. Проблема вроде бы в двойном удалении
  блока памяти.
     Ремастеринг: Организация менеджера памяти для хранения блоков памяти
  процесса, с сохранением ассоциации с памятью исследуемого процесса. Использование
  счетчиков ссылок позволит блоки эти использовать при многозапросном поиске. Эта задача на
  выходные.

  23.02.2005. Праздничный день
  Создание конструктора трейнеров, позволяющего создавать описание диалоговых окон для
  трейнеров, связывать с адресами различные элементы управления. Рендер этих окон с всем
  функционалом будет размещатся в DLL. Изначально он будет написан на Delphi + WinAPI.
  Инвариант рендер - небольшое приложение которое может закачивать еще более мелкие
  описания трейнеров.
  Конструктор трейнеров: система рисования окон на подобии Delphi/Builder, с поддержкой
  guide-lines VStudio. При создании окна трейнера это окно проецируется на форму конструктора
  как дочерний элемент управления. Крупные окна придется рисовать в скроллируемом компоненте. 


  Полный список функциональности готового трейнера:
  1. Поддержка различных вариантов присвоение, прибавления, заморозки исходного значения.
  2. Поддержка элементов управления: BUTTON, COMBOBOX, EDIT, IMAGE, LISTBOX, MENU, PANEL,
  STATIC, TRACKLBAR
  4. Поддержка горячих клавиш


  TODO:
    Поддержка базы данных чит-кодов/адресов/солюшенов и прочей полезности. Автоматическая подгрузка
  нужных файлов для выбранной игры. Для каждой игры используется один файл в котором описывается вся
  полезная инфа: чит-коды, адреса, информация для запуска игры и автоопределения процесса.


 Поддержка сетевой связи между компонентами взломщика.

 Реализовано:
  + Получение списка процессов в пространстве сервера.
  + Поиск/Отсев значений, с передачей части указателей в клиентский процесс.

 Необходимо реализовать:
  * Поддержку таблицы активных значений на уровне процесса сервера.
    Как интерфейс должен быть реализован механизм добавления/удаления адресов
    (абстрагированный от реализации их сохранения на стороне сервера), и возможность
    получения сообщений об изменении значений (для обновления в клиентском процессе).
  * Удаленная консоль - своего рода примитивная система удаленного администрирования.    
  * Ввод чит-кодов на строне серверного процесса


  Проблемы настоящего:
  Долгое ожидание получения списка процессов.
  1. Можно организовать splash-окно которое будет держаться до прибытия
  процессов (без значков), проявляя какую-нибудь графическую активность.
  2. Попытаться оптимизировать по максимому startup-процесс. Например
  весь консольный вывод отвести в асинхронный режим (возможно
  и в отдельный поток).


