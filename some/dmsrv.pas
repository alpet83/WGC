unit dmsrv;
{ Модуль конкретно посвящен механизму быстрой динамической памяти }
interface
uses SysUtils, Windows;
type
    TDMCmd = (MALLOC, MFREE, MRESIZ, MRESZCOPY);

const
   MBLCKFIXED = 1; // Флажок для создания фиксированных блоков памяти


function    dmem (var x, d;const size, flags : dword;const cmd : TDMCmd) : LongInt;

implementation
{
--------------------------------------------------------------------
Разбор:
 1. Захват блока памяти
 2. Изменение его размера
 3. Освобождение за ненадобностью

Словарь:
 - набор списков ориентированных на блоки разной длины
 - все списки матрицированны, нет связанных и кольцевых списков
 - регулируемое кэшырование заема памяти - нечего беспокоить систему
 - архитектура освобождения блоков - фрагментируемая, когда фрагментация
   станет невыносимой производится дефрагментация (сливание малых свободных
   блоков в крупные).

 - резервирование памяти возможно (с некоторым лимитом) на уровне
   проекций файлов - FileMapping. Это поможет при разделении оперативной
   памяти между процессами и manual swap;
 - механизмы содержания описателей блоков возлагаются на клиентскую сторону.
 - для зашаренной памяти поддерживается мехнизм имен (не нужно открывать
   множество проекций) что поможет избавиться от громадной структуры SM.
}

(*
   Программирование с использованием нового менеджера памяти имеет
 несущественные отличия.
  1. Для ускорения обработки дескрипторов блоков, клиентская сторона (прога)
     должна сохранять адрес и дескриптор блока.
  2. В условиях создания многопроцессных и многопоточных приложений (комплексов)
     оптимизирование внутренних структур менеджера возлагается также на
     клиентскую сторону - она должна вызывать соответствующие процедуры
     дефрагментации и обмена блоков виртуальной памяти (диск - память).
  3. При распределении общей памяти, поддерживается структура каталогов и имен
     блоков. Ex: "comp\Application\Struct1\VarX"
*)

{  Задача эффективного (по скорости) распределения динамической памяти.
 Наиболее полно эта задача может решаться при учете специфики создаваемой
 программы - ее поведения при использовании ДРП. Эту специфику определяют
 такие свойства как: размеры блоков используемые программой, наличие
 некоторой упорядоченности при распределении/освобождении этих блоков.
 Определяется она при профилировании программы, наблюдения трассы запросов.
   Не менее важной является и универсальная часть менеджера, которая должна
 действовать эффективно в любом случае. Для реализации предполагается два
 варианта: распределение с полноценным использованием остатков (1) и
 периодическая дефрагментация остатков (2).
   В первом случае, для распределения блока памяти, менеджер сканирует массивы
 со описаниями блоков больших или равных запрашиваемуму, для нахождения
 наименьщего из подходящих. После этого, либо блок отдается целиком, либо от
 него опять остается остаток. Этот способ является стандартным для большинства
 используемых систем.
   Во втором случае блоки всегда резервируются с конца свободного большого
 блока. Естественно при таком расходе большой блок быстро заканчивается.
 В моменты низкой загруженности ЦП, остатки (дыры от высвобожденных блоков)
 должны сливаться в один большой блок. Реализация этого способа требует
 чтобы указатели всех блоков перед дефрагментацией были разблокированы, чтобы
 менеджер смог их изменять, поэтому программе придется хранить не указатели, а
 дескрипторы блоков. Типично этот способ реализован в WINAPI32 функциями
 GlobalAlloc, GlobalLock, GlobalUnlock и GlobalFree. Этот способ скорее всего
 себя не оправдает, из наличия механизмов блокировки/разблокировки памяти.
 }
function    dmem;
begin
 result := 0; // No Error
end;

end.
